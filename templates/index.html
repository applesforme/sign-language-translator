<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sign Language Translator</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.0/socket.io.min.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <style>
        .ex-layout {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .gnb {
            padding: 20px;
            background-color: #333;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .main {
            flex-grow: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
        }

        #container {
            position: relative;
            width: 640px;
        }

        #videoElement {
            width: 640px;
            height: 480px;
            background-color: #666;
            transform: scaleX(-1);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            transform: scaleX(-1);
        }

        .prediction-container {
            margin: 10px 0;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 5px;
        }

        .prediction-label {
            margin-bottom: 5px;
            font-size: 14px;
            color: #333;
        }

        .prediction-bar {
            height: 20px;
            transition: width 0.3s ease;
            color: white;
            text-align: right;
            padding-right: 5px;
            line-height: 20px;
            border-radius: 3px;
            width: 0;
        }

        .footer {
            padding: 20px;
            background-color: #f8f9fa;
        }

        #result {
            width: 100%;
            height: 80px;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 5px;
            resize: none;
        }

        .button, .button2, .button3 {
            padding: 8px 15px;
            border-radius: 5px;
            text-decoration: none;
            color: white;
            margin: 0 5px;
            cursor: pointer;
            border: none;
            font-size: 14px;
        }

        .button { background-color: #4CAF50; }
        .button:hover { background-color: #45a049; }
        .button:disabled { background-color: #cccccc; cursor: not-allowed; }

        .button2 { background-color: #f44336; }
        .button2:hover { background-color: #da190b; }
        .button2:disabled { background-color: #cccccc; cursor: not-allowed; }

        .button3 { background-color: #2196F3; }
        .button3:hover { background-color: #0b7dda; }
        .button3:disabled { background-color: #cccccc; cursor: not-allowed; }

        .status-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            border-radius: 3px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 12px;
            z-index: 2;
        }

        #predictions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: calc(100% - 20px);
            z-index: 2;
        }

        #loadingProgress {
            height: 20px;
            background-color: #4CAF50;
            transition: width 0.3s ease;
            border-radius: 3px;
            width: 0;
        }
    </style>
</head>
<body>
    <div class="ex-layout">
        <div class="gnb">
            Sign Language Translator
            <div class="item last">
                <button onclick="startCapture()" class="button" id="startBtn" disabled>Start (S)</button>
                <button onclick="finishCapture()" class="button3" id="finishBtn" disabled>Finish (F)</button>
            </div>
        </div>
        <div class="main">
            <div id="container">
                <video autoplay playsinline id="videoElement"></video>
                <canvas id="canvas"></canvas>
                <div id="status" class="status-indicator">Loading model...</div>
                <div id="predictions">
                    <div class="prediction-container">
                        <div class="prediction-label">Model Loading Progress</div>
                        <div id="loadingProgress"></div>
                    </div>
                    <div class="prediction-container">
                        <div class="prediction-label" id="label1"></div>
                        <div class="prediction-bar" id="pred1"></div>
                    </div>
                    <div class="prediction-container">
                        <div class="prediction-label" id="label2"></div>
                        <div class="prediction-bar" id="pred2"></div>
                    </div>
                    <div class="prediction-container">
                        <div class="prediction-label" id="label3"></div>
                        <div class="prediction-bar" id="pred3"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="footer">
            <textarea id="result" readonly placeholder="Translated text will appear here..."></textarea>
        </div>
    </div>

    <script type="text/javascript">
        var socket = io.connect(window.location.protocol + '//' + document.domain + ':' + location.port);
        const videoElement = document.querySelector("#videoElement");
        const canvasElement = document.querySelector("#canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const status = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const finishBtn = document.getElementById('finishBtn');
        const loadingProgress = document.getElementById('loadingProgress');
        let isStarted = false;
        let holistic = null;

        canvasElement.width = 640;
        canvasElement.height = 480;

        // Initialize holistic model first
        async function initializeHolistic() {
            holistic = new Holistic({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;
                }
            });

            holistic.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            // Set up progress monitoring
            let totalFiles = 0;
            let loadedFiles = 0;

            holistic.onProgress = (packet) => {
                if (packet.totalFiles) {
                    totalFiles = packet.totalFiles;
                }
                if (packet.loadedFiles) {
                    loadedFiles = packet.loadedFiles;
                    const progress = (loadedFiles / totalFiles) * 100;
                    loadingProgress.style.width = progress + '%';
                    status.textContent = `Loading model... ${Math.round(progress)}%`;
                }
            };

            await holistic.initialize();
            
            // Enable buttons after model is loaded
            startBtn.disabled = false;
            finishBtn.disabled = false;
            status.textContent = "Model loaded. Ready to start.";
            loadingProgress.style.width = '100%';
            
            // Set up the results handler
            holistic.onResults(onResults);
        }

        // Start loading the model immediately
        initializeHolistic().catch(error => {
            console.error("Error loading model:", error);
            status.textContent = "Error loading model";
        });

        function onResults(results) {
            if (!isStarted) return;

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.faceLandmarks) {
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION,
                    {color: '#C0C0C070', lineWidth: 1});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_RIGHT_EYE,
                    {color: '#FF3030'});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_RIGHT_EYEBROW,
                    {color: '#FF3030'});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_LEFT_EYE,
                    {color: '#30FF30'});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_LEFT_EYEBROW,
                    {color: '#30FF30'});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_FACE_OVAL,
                    {color: '#E0E0E0'});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_LIPS,
                    {color: '#E0E0E0'});
            }

            if (results.poseLandmarks) {
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                    {color: '#00FF00', lineWidth: 4});
                drawLandmarks(canvasCtx, results.poseLandmarks,
                    {color: '#FF0000', lineWidth: 2});
            }

            if (results.leftHandLandmarks) {
                drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS,
                    {color: '#CC0000', lineWidth: 5});
                drawLandmarks(canvasCtx, results.leftHandLandmarks,
                    {color: '#00FF00', lineWidth: 2});
            }
            if (results.rightHandLandmarks) {
                drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS,
                    {color: '#00CC00', lineWidth: 5});
                drawLandmarks(canvasCtx, results.rightHandLandmarks,
                    {color: '#FF0000', lineWidth: 2});
            }

            canvasCtx.restore();

            if (results.faceLandmarks || results.leftHandLandmarks || 
                results.rightHandLandmarks || results.poseLandmarks) {
                const keypoints = {
                    face: results.faceLandmarks || [],
                    pose: results.poseLandmarks || [],
                    leftHand: results.leftHandLandmarks || [],
                    rightHand: results.rightHandLandmarks || []
                };
                socket.emit('keypoints', keypoints);
            }
        }

        function startCapture() {
            if (!isStarted && holistic) {
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        if (isStarted) {
                            await holistic.send({image: videoElement});
                        }
                    },
                    width: 640,
                    height: 480
                });

                camera.start()
                    .then(() => {
                        isStarted = true;
                        status.textContent = "Recording...";
                        document.getElementById('result').value = "Translation started.";
                    })
                    .catch((error) => {
                        console.error("Error starting camera:", error);
                        status.textContent = "Error: Cannot access webcam";
                    });
            }
        }

        function finishCapture() {
            if (isStarted) {
                isStarted = false;
                const tracks = videoElement.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                videoElement.srcObject = null;
                status.textContent = "Finished";
                console.log("Final sentence:", document.getElementById('result').value);
            }
        }

        function updatePredictionBars(predictions) {
            const colors = ['#4CAF50', '#2196F3', '#FFC107'];
            predictions.forEach((pred, i) => {
                const bar = document.getElementById(`pred${i+1}`);
                const label = document.getElementById(`label${i+1}`);
                const width = pred.probability * 100;
                
                bar.style.width = width + '%';
                bar.style.backgroundColor = colors[i];
                label.textContent = `${pred.word} (${width.toFixed(1)}%)`;
            });
        }

        socket.on('predictions', function(data) {
            if (data.predictions) {
                updatePredictionBars(data.predictions);
            }
            if (data.sentence) {
                document.getElementById('result').value = data.sentence;
            }
        });

        document.addEventListener('keydown', function(event) {
            if (!startBtn.disabled) {
                switch(event.key.toLowerCase()) {
                    case 's':
                        startCapture();
                        break;
                    case 'f':
                        finishCapture();
                        break;
                }
            }
        });

        window.onbeforeunload = function() {
            if (isStarted) {
                finishCapture();
            }
        };
    </script>
</body>
</html>
